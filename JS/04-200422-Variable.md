# 변수

## 변수란 무엇인가? 왜 필요한가?

애플리케이션은 데이터를 입력(input) => 데이터를 출력(output)

변수는 데이터를 관리하기 위한 핵심 개념

```javascript
10 + 20 // 숫자 값 10과 20을 + 연산자(operator)로 합산
```

CPU가 + 연산을 수행하기 위해서는 먼저 + 연산자의 좌변과 우변의 숫자값, 즉 피연산자(operand)를 기억해야 한다. 컴퓨터는 **메모리**를 사용해 데이터를 기억한다.

> **메모리**
>
> 데이터를 저장할 수 있는 메모리 셀의 집합체
>
> 셀 하나의 크기는 1Byte(8bit)이며 1Byte 단위로 데이터를 저장(write)하거나 읽어(read)들인다. 컴퓨터는 모든 데이터를 2진수로 처리한다. 각각의 셀은 고유의 메모리 주소(memory address)를 가지며 이 메모리 주소는 메모리 공간의 위치를 나타내며 0부터 시작하여 메모리 크기만큼 정수로 표현된다. 예를 들어 4GB의 메모리는 0부터 4,294,967,295(0x00000000 ~ 0xFFFFFFFF)까지의 메모리 주소를 갖는다.
>
> ※ DRAM에는 프로그램을 수행하는 명령어(Instruction)와 그 명령이 실행되는 데이터(Data)가 함께 들어 있는데, 명령어는 읽기만 하고 데이터는 읽기와 쓰기를 동시에 한다.
>
> - 1셀(cell) 8bit => 8비트가 나타낼수 있는 경우의 수 256
>
> - bit( 0 / 1 ) => 2진수가 표현할 수 있는 최소 단위

숫자 값 10과 20은 메모리 상의 임의의 위치(메모리 주소, memory address)에 기억(저장)되고 CPU는 이 값을 읽어들여 연산을 수행한다. 연산 결과로 생성된 숫자 값 30도 메모리 상의 임의의 위치에 저장된다.

```javascript
10 + 20 // 30 => CPU가 연산하여 만들어낸 숫자 값 30은 재사용할 수 없다
```

연산결과 30을 재사용 하려면 메모리가 저장된 방을 찾아야한다. 저장된 메모리 공간에 직접 접근하는 것은 올바른 방법이 아니다. 프로그래밍 언어는 기억을 하고 싶은 값을 메모리에 저장하고 저장된 값을 읽어 들여 재사용하기 위해 변수라는 메커니즘을 제공한다.

**변수의 정의** : **변수(Variable)는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름을 말한다.** 프로그래밍 언어에서 값을 저장하고 참조하는 메커니즘으로 **값의 위치를 가리키는 상징적인 이름**

```javascript
var a = 10 + 20; // a가 있는 위치를 기억하므로 재사용이 가능해진다
// 변수를 만드는 이유는 나중에 꼭 쓰겠다는 의미(한번만 쓰고 안쓸꺼면 변수에 담을 필요가 없다)
// 변수는 하나의 값을 기억하기 위해서 확보한 메모리 공간 또는 메모리 공간을 기억하는 이름
// a => 변수이름 식별자
// 메모리 공간 => 변수
```

> 변수에 값을 저장하는 것을 **할당(assignment 대입, 저장)**이라 하고, 변수에 저장된 값을 읽어 들이는 것을 **참조(reference)**라고 한다.

```javascript
var a = 10 + 20; // a 변수 할당
// 10, 20 숫자 literal
// 10 + 20 표현식(값)
```

```Javascript
var x = 1;

// 자바스크립트의 엔진이 해석하는 방법
var x; // => 변수 선언
x = 1; // => 변수 값에 할당
```



## 식별자

**식별자는 어떤 값을 구별하여 식별해낼 수 있는 고유한 이름**

```javascript
var result = 30; // result가 기억하는 것은 메모리 주소 0x0669F913
```

**식별자는 값이 아니라 메모리 주소를 기억**

식별자로 값을 구별하여 식별한다는 것은 식별자가 기억하고 있는 메모리 주소를 통해 메모리 공간에 저장된 값에 접근할 수 있다는 것을 의미

변수, 함수, 클래스 등의 이름은 모두 식별자

메모리 상에 존재하는 어떤 값을 식별할 수 있는 이름은 모두 식별자

**선언(declaration)**에 의해 자바스크립트 엔진에 식별자의 존재를 알린다



## 변수 선언

변수 선언(Variable declaration)이란 변수를 생성하는 것

값을 저장하기 위한 메모리 공간을 확보(allocate, 할당)하고 변수 이름과 확보된 메모리 공간의 주소를 연결(name binding)하여 값을 저장할 수 있도록 준비하는 것

**변수를 사용하려면 반드시 선언이 필요하다. 변수를 선언할 때는 var, let, const 키워드를 사용**

```javascript
var score; // 변수 선언(변수 선언문)
           // var 키워드는 뒤에 오는 변수 이름으로 새로운 변수를 선언할 것을 지시하는 키워드
           // 변수를 선언하고 아직 변수에 값을 할당하지 않았으므로 undifined
```

> **키워드**
>
> 키워드(keyword)는 자바스크립트 코드를 해석하고 실행하는 자바스크립트 엔진이 수행할 동작을 규정한 일종의 명령어이다. 자바스크립트 엔진은 키워드를 만나면 자신이 수행해야 할 약속된 동작을 수행한다. 예를 들어 var 키워드가 실행되면 자바스크립트 엔진은 뒤에 오는 변수 이름으로 새로운 변수를 선언한다.

자바스크립트 엔진은 변수 선언을 아래의 2단계를 거쳐 수행한다.

- 선언 단계(Declaration phase) : 변수 이름을 등록하여 자바스크립트 엔진에 변수의 존재를 알린다.
- 초기화 단계(Initialization phase) : 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 `undefined`를 할당한다.

변수를 사용하려면 반드시 선언이 필요하다. 그렇지 않다면 ReferenceError(참조 에러)가 발생한다.



## 변수 선언의 실행 시점과 변수 호이스팅

```javascript
console.log(score); // undefined
                    // 순차적으로 실행되었다면 변수 선언이 안되었기 때문에
                    // ReferenceError(참조 에러)가 발생해야한다
var score;          // 변수 선언문
```

자바스크립트 엔진은 **변수 선언**이 소스 코드의 어디에 있던지 상관없이 다른 코드보다 **먼저 실행**한다. 따라서 변수 선언이 소스 코드에 어디에 있던지 상관없이 변수를 참조할 수 있다. **변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징**을 **변수 호이스팅(Variable Hoisting)**이라 한다.



## 값의 할당

변수에 값을 할당(assignment 대입, 저장)할 때는 할당 연산자(=)를 사용한다. 할당 연산자는 우변의 값을 좌변의 변수에 할당한다.

```javascript
var score;  // 변수 선언
score = 80; // 값의 할당
```

변수 선언과 값의 할당을 아래와 같이 하나의 문(statement)로 단축 표현할 수도 있다.

```javascript
var score = 80; // 변수 선언과 값의 할당
```

**변수 선언은 소스 코드가 순차적으로 실행되기 이전, 즉 런타임 이전에 먼저 실행되지만 값의 할당은 소스 코드가 순차적으로 실행되는 시점인 런타임에 실행된다.**

```javascript
console.log(score); // undefined

var score = 80;     // 변수 선언과 값의 할당

console.log(score); // 80

// 변수 선언과 값의 할당을 동시에 해도 자바스크립트 엔진은 그것을 분리하여
// 변수 선언은 런타임 이전에 먼저 실행되지만 값의 할당은 런타임 시점에 실행된다
```

변수에 값을 할당할 때는 이전 값 `undefined`가 저장되어 있던 메모리 공간을 지우고 그 메모리 공간에 할당 값 80을 새롭게 저장하는 것이 아니라 새로운 메모리 공간을 확보하고 그 메모리 공간에 할당 값 80을 저장하는 것에 주의



## 값의 재할당

재할당이란 이미 값이 할당되어 있는 변수에 새로운 값을 또다시 할당하는 것을 말한다.

```javascript
var score = 80; // 변수 선언과 값의 할당
score = 90;     // 값의 재할당

// 변수는 선언과 동시에 undefined로 초기화되기 때문에
// 엄밀히 말하자면 변수에 처음으로 값을 할당하는 것도 사실은 재할당
```

`var`키워드로 선언한 변수는 값을 재할당 할 수 있다. 재할당은 변수에 저장된 값을 다른 값으로 변경한다. 따라서 **변수**라 부른다. 만약 **재할당을 할 수 없어서 변수에 저장된 값을 변경할 수 없다면 변수가 아니라 상수(Constant)라 부른다.** 상수는 한번 정해지면 변하지 않는 값이다. 다시 말해 상수는 단 한번만 할당할 수 있는 변수이다.

변수에 값을 재할당하면 변수 score는 이전 값 80에서 재할당 값 90으로 변경된다. 처음 값을 할당했을 때와 마찬가지로 이전 값 80이 저장되어 있던 메모리 공간을 지우고 그 메모리 공간에 재할당 값 90을 새롭게 저장하는 것이 아니라 새로운 메모리 공간을 확보하고 그 메모리 공간에 숫자 값 90을 저장한다.

현재 변수 score의 값은 90이다. 변수 score의 이전 값인 undefined와 80은 어떤 변수도 값으로 갖고 있지 않다. 이것은 undefined과 80이 더이상 필요하지 않다는 것을 의미한다. 아무도 사용하고 있지 않으니 필요하지 않은 것이다. 이러한 불필요한 값들은 가비지 컬렉터(Garbage Collector)에 의해 메모리에서 자동 해제된다. 단, 메모리에서 언제 해제될 지는 예측할 수 없다.

>**가비지 컬렉터(Garbage Collector)**
>
>가비지 컬렉터는 애플리케이션이 할당(allocate)한 메모리 공간을 주기적으로 검사하여 더 이상 사용되고 있지 않는 메모리를 해제(release)하는 기능을 말한다. 더 이상 사용되고 있지 않는 메모리란 간단히 말하자면 어떤 식별자도 참조하고 있지 않는 메모리 공간을 의미한다. 자바스크립트는 가비지 컬렉터를 내장하고 있는 매니지드 언어이다. 이를 통해 메모리 누수(memory leak)를 방지한다.

> **언매니지드 언어와 매니지드 언어**
>
> 프로그래밍 언어는 메모리 관리 방식에 의해 언매니지드 언어(Unmanaged Language)와 매니지드 언어(Managed Language)로 분류할 수 있다.
> C 언어와 같은 언매니지드 언어는 개발자가 명시적으로 메모리를 할당하고 해제하기 위해 malloc()과 free()와 같은 저수준(low-level) 메모리 관리 기능을 제공한다. 언매니지드 언어는 메모리 관리를 개발자가 주도하므로 개발자의 역량에 의해 최적의 퍼포먼스를 확보할 수 있지만 그 반대의 경우, 치명적 오류를 생산할 가능성도 동시에 존재한다.
> 자바스크립트와 같은 매니지드 언어는 메모리의 할당 및 해제를 위한 메모리 관리 기능을 언어 차원에서 담당하고 개발자의 직접적인 메모리 제어를 허용하지 않는다. 즉, 개발자가 명시적으로 메모리를 할당하고 해제할 수 없다. 더 이상 사용하지 않는 메모리의 해제는 가비지 컬렉터(Garbage Collector)가 수행하며 이 또한 개발자가 관여할 수 없다. 매니지드 언어는 개발자의 역량에 의존하는 부분이 상대적으로 작아져 어느 정도 일정한 생산성을 확보할 수 있는 장점이 있지만 퍼포먼스 면에서의 손실은 감수할 수 밖에 없다.



## 값의 교환

```javascript
var x = 1;
var y = 2;

// do something
var z = y; // z = 2
y = x;	   // y = 1
x = z;	   // x = 2

console.log(x, y); // 2 1
```



## 식별자 네이밍 규칙

식별자는 어떤 값을 구별하여 식별해낼 수 있는 이름

- 식별자는 특수문자를 제외한 문자, 숫자, underscore( _ ), 달러 기호($)를 포함할 수 있다.

- 단, 식별자는 특수문자를 제외한 문자, underscore( _ ), 달러 기호($)로 시작해야 한다. 숫자로 시작하는 것은 허용하지 않는다.

- 예약어는 식별자로 사용할 수 없다.

  ```javascript
  var first-name; // SyntaxError: Unexpected token –
  				// '-'를 연산자로 인식
  var 1st;        // SyntaxError: Invalid or unexpected token
  var this;       // SyntaxError: Unexpected token this
  ```

  

- 자바스크립트는 대소문자를 구별한다.

  ```javascript
  // 각각 별개의 변수
  var graves;
  var Graves;
  var GRAVES;
  ```

- 변수 이름은 존재 목적을 쉽게 이해할 수 있도록 의미를 명확히 표현해야 한다.

  ※ 변수 선언에 별도의 주석이 필요하다면 변수의 존재 목적을 명확히 드러내지 못하는 것이다.

  ```javascript
  // 경과 시간, 단위는 날짜이다
  var d;                 // NG
  
  var elapsedTimeInDays; // OK
  ```

- 네이밍 컨벤션

  ```javascript
  // 카멜 케이스 (camelCase)
  var firstName;
  
  // 스네이크 케이스 (snake_case)
  var first_name;
  
  // 파스칼 케이스 (PascalCase)
  var FirstName;
  
  // 헝가리언 케이스 (typeHungarianCase)
  var strFirstName;          // type + identifier
  var $elem = $('.myClass'); // jQuery
  						   // 가끔 DOM 요소 Query시 변수에 DOM이 들어가 있다는 것을 명시할 때
  ```

  가장 일반적인 것은 **변수나 함수의 이름에는 카멜 케이스**를 사용하고 **생성자 함수, 클래스의 이름에는 파스칼 케이스**를 사용하는 것
  
- 코드의 품질을 측정하는 2가지

  - 가독성
  - 성능



## 컴퓨터에서 쓰는 단위

### **Hz**

**속도를 나타내는 Hz**

CPU를 비롯한 PC의 모든 부품들은 일정한 간격(속도)로 발생하는 **전기적 신호(pulse)**에 맞추어 동작하는데 이 전기전 신호를 **클럭(clock)**이라고 한다. 이 전기적 신호 가 발생하고 바로 다음 신호가 또 발생할 때까지의 간격을 한 **사이클(cycle)**이라고 하며, 이것을 표기할 때 **Hz**로 표기한다. **Hz**는 1초에 몇 번이 전기적인 신호가 발생했는지를 나타내는 단위로 1Hz는 1초에 1번의 전기적인 신호가 발생하는 것이다.  CPU의 클럭이 4GHz라면 4십억 번의 사이클로 0과 1의 디지털 신호가 발생하는 것이다.

※ 전기적 신호는 0과 1로 구분하며 0에서 1로, 1에서 0으로 변하는 특정 신호에 반응하는 엣지 디렉팅 방식과 0과 1자체에 반응하는 레벨 디렉팅 방식이 있다.



### **bit**

**크기를 나타내는 bit**

**bit**는 '**b**inary digi**t**' 이진 숫자의 약자이다. PC는 0과 1의 숫자로 동작하는게 기본인데 여기서 0은 Off를 1은 On을 의미한다. 0을 입력하여 전기적 신호를 끊고 1을 입력하여 전기신호를 넣는 작업을 반복함으로써 구동된다. 컴퓨터가 표현하는 2진수의 가장 작은 단위가 1bit이다. 알파벳 한 단어를 표현하려면 8bit = 1Byte가 필요하다. Byte는 KiloByte(킬로바이트), MegaByte(메가바이트), GigaByte(기가바이트), Tera Byte(테라바이트) 순으로 약 1000배(2^10)씩 커진다.

note) **bps** : '**b**it **p**er **s**econd' 1초에 몇 bit의 데이터를 주고 받는지를 나타내는 단위



#### 문자 인코딩

컴퓨터와 커뮤니케이션을 할 수 있도록 문자 코드를 전산기기 안에서 0, 1로 저장하는 방식

**발전 과정**

7비트(**ASCII**)로는 다른 언어를 표현하기 부족

=> 8비트 아스키(**ANSI** 코드) 등장(256개)

=> 전 세계 언어의 문자를 정의하기 위해 국제 표준 코드 **Unicode**가 등장

- **ASCII**(**A**merican **S**tandard **C**ode for **I**nformation **I**nterchange)

  1960년대 미국에서 정의한 표준화한 부호체계

  7비트(128개)의 고유한 값만 사용

  컴퓨터의 기본 저장단위는 1바이트(8비트)지만 1비트는 통신에러를 검출하기 위해 사용(Parity Bit)

  0x00부터 0x7F까지의 총 128개(인쇄, 전송 제어용, 알파벳 소/대문자, 특수기호 등)의 고유값을 할당

- **Unicode**

  전 세계 언어의 문자를 정의하기 위해 등장한 국제 표준 코드

  사용중인 운영체제, 프로그램, 언어에 관계없이 문자마다 고유한 코드 값을 제공하는 새로운 개념의 코드

  언어와 상관없이 모든 문자를 16비트로 표현하므로 최대 65,536자까지 표현

  유니코드 인코딩 방식으로는 UTF-7, UTF-8, UTF-16, UTF-32 등

  - **UTF-8**

    UTF-8은 멀티바이트 개념을 사용하여 하나의 Character Set에 거의 모든 문자를 넣음

    첫 128자는 ASCII 코드 값으로 ANSI와 UTF-8이 동일하다. 그래서 영어를 사용할 경우 1byte만 사용

    2bytes를 사용하며 중동지역 언어 또는 많은 유럽 언어가 여기에 속함

    한국, 중국, 일본 등 동아시아권 언어는 3bytes 이상을 사용

    

## Lecture

상태머신은 input을 받아 output을 출력(IPO: Input Process Output)

브라우저 인풋(URL, click, focus 등) => 아웃풋(화면)

변수는 인풋 아웃풋 즉 데이터를 관리

Program Process

HDD, SSD(물리적으로 저장된 파일, 느림) -> Memory(전기 신호로 저장, 전원 나가면 날아감, 전기 신호기 때문에 훨씬 빠름, 모든 실행프로그램이 사용하기 때문에 한정된 리소스) 

메모리를 사용하기 위해서는 예약을 해야함 => 예약을 하면 할당(확보, allocate) => 할당이 되면 다른데에서 쓰지 못하기 때문에 빨리 쓰고 빨리 해방해야 함 => 해방을 하지 않았을 시 다른 애플리케이션들이 기다려야됨(일명 렉 발생) => 변수를 쓰는것은 메모리를 먹는것, 스코프(scope) 변수는 빨리 생성되서 빨리 사라짐

※ 변수는 적을수록 좋다(에러 발생의 근본 원인)

전역변수 브라우저가 가동하기 시작하기부터 메모리를 확보 그 애플리케이션이 종료하기 이전까지는 그 메모리 영역을 풀어주지않는다. 계속 잡고 있다 전역변수는 많을수록 안좋다. 태생적한계 브라우저의 보조적 역할 전역변수를 쓰고 싶어도 사용하지 않고 대신 모듈, 클로저를 써야된다 메모리의 최소기억단위 1바이트 데이터로서 의미를 갖기 위해선 최소 8bit = 1byte, 1은 이진수로도 1로 표현 1비트로 표현 가능하긴함 

자바스크립트는 기본적으로 메모리 주소를 알려주지 않는다. 브라우저는 메모리 관리를 OS에게 부탁한다.

C언어의 경우 포인터 메모리 주소 알 수 있다. C언어는 OS를 만들기 위해 태어난 언어

메모리는 기억, 저장 연산은 CPU가 담당

CPU와 메모리는 서로 데이터를 주고 받음 => 전기적 신호로 주고 받음

```javascript
10 + 20; // 같은 10 + 20 이어도 2번 선언 했을 때
10 + 20; // 둘의 저장된 메모리 주소가 다르다
```

대부분의 프로그래밍 언어는 변수의 정의는 같다

키워드(명령어, 프로그래밍 언어와 개발자의 약속), 식별자 , 리터럴 끼리 공통된 색깔을 쓴다

JS 엔진

```javascript
var result = 10 + 20;
// var result; 값이 없는 변수 선언 몇바이트로 확보해야되냐?
// result라는 이름이 메모리주소를 기억한다
// 인터프리터가 result의 메모리 주소를 기억
// 10 + 20;
// JS 엔진은 이렇게 읽음

// 메모리는 계속 재사용 되기때문에 안쓰는 쓰레기값이 들어 있을수가 있음
// 처음 값을 할당하면 초기화해야됨 다른 언어는 할당할때 초기화를 시켜주어야 한다
// 쓰레기 값이 들어있을수가 있어서
// 자바스크립트는 착해서 변수를 선언하면 암묵적으로 초기화를 해준다 => undefined
// 내부동작을 이해하기 어렵다
// 정의 vs 선언
// 정의 : 밝혀지지 않은 것을 확실하게 
// 할당 되면 값이 명확해지는 것을 정의 그래서 아직 정의되지 않았다 undefined
// var는 undefined bit size만큼을 확보
// let const는 얘기가 달라짐
```

콘솔로그에서 참조된 식별자가 메모리 주소를 기억 바꿔치기

변수의 목적 하나의 값을 저장하기 위해서 확보한 메모리 공간 자체 또는 메모리 주소를 가르키는 이름

키워드 : 명령어

변수 이름 : 

연산자 이 뒤에는 값이 있어야된다리

똑같은 코드라도 위치에 따라 달라짐 => 코드는 문맥이 있다

10 + 20 이상태를 변수에 저장할 수 없다

코드 메모리 주소 할당

몇 바이트 할당할까 undefined 들어갈만큼만 확보하자

변수 선언 두단계

변수 선언, 초기화 => 한방에 이게 변수선언

 순서 표현식(10 + 20)

메모리 해제 코드 x 

C언어는 경우에 따라 프로그래머가 해제해야됨



|             식별자              | 메모리 주소 |     메모리      |
| :-----------------------------: | :---------: | :-------------: |
|                                 | 0x0???????  |       10        |
|                                 | 0x0???????  |                 |
| ~~result~~(①의 메모리 주소에서) | ~~==①==>~~  | ?? => undefined |
|                                 | 0x0???????  |       20        |
| result(②의 메모리 주소로 변경)  |   ==②==>    |       30        |



가비지 컬렉터가 쓰였던 메모리 주소를 쓸수 있게 해줌(undefined, 10, 20)(지우지는 않는다)

var result 상황에 쓰레기들을 그대로 둘수 없어서 undefined

10 + 20은 정확히 말하면 재할당이긴함

reference error 참조 에러 나온다

```javascript
console.log(result);
var result = 10 + 20;
// var result 변수 선언문
// result = 10 + 20; 변수 할당문
// 컴파일러는 순서대로 실행되기 때문에 다른 언어는 Ref error가 나온다
// 자바스크립트는 undefined가 나온다
// 정통의 C언어는 변수들을 위에 쓰는게 컨벤션
// undefined가 나오면 참조가 됫다는 말인데
// 호이스팅
// 코드가 한줄 한줄 실행되는 시점을 런타임이라고 함
// 런타임이 되기전에 소스코드를 평가
// 모든 소스코드를 발췌해서 먼저 실행
// 이유는 다른 엄격한 언어는 컨벤션
// 자바스크립트는 착해서 위로 올려서 먼저 해석해줌
// 변수선언문, 함수선언문, 클래스선언문 등은 먼저 실행
// 그래서 끌어올려서 undefined가 나온다 좋은게 아니다 부작용데스네
// 이건 변수선언문
// 함수선언문은 조금 다르다
// 이것을 변수 호이스팅이라고 따로 부르자
// 코드가 먼저 실행되는 거지 끌어 올려지는건 아니다
```



```javascript
// var의 경우 undefined

console.log(result);	// 2. undefined
result = 10 + 20;		// 1. 선언 3. 할당
var result;				// 실행 X
console.log(result);	// 4. 30
```



```javascript
// let, const의 경우 ReferenceError가 발생

console.log(result);	// ReferenceError
result = 10 + 20;		// 30
let result;				// undefined
console.log(result);	// undefined

						// let, const 엄격하게 말하면 호이스팅이 발생하긴 하지만
						// 발생하지 않는 것처럼 자바스크립트 엔진이 동작한다
```



식별자(**id**entifier)

자로 끝나는 css 선택자

css id도 identifier

여러가지 중에 하나를 구별해서 식별해 낸다는 얘기죠? 그런 의미를 닮고 있는 애들은 다 식별자에요

id는 고유해야한다 식별하려면 

어떤 값을 구별하여 식별해낼 수 있는 고유한 이름(scope 내에서)

파일명은 그 폴더 내에서 고유 => scope 기준이 있다

변수는 scope 내에서 고유하면 된다

자바스크립트에선 독특하게 함수가 객체라는 값이다 함수 이름도 식별자

클래스도 이름이 있다 클래스가 사실 함수 클래스의 이름도 식별자

패턴화 => 선언하는 애들은 다 식별자구나

선언문들은 이름을 지을 때 규칙이 있다 나중에 설명



선언 단계 변수 이름을 등록(실행 컨텍스트라는 자료구조에 등록)하여 자바스크립트 엔진에 변수(식별자)의 존재를 알린다 등록될때 스코프얘기 몇단계가 지나가야 어디에 등록되는지 이해

초기화 단계 : 메모리 공간을 확보하고 자바스크립트 엔진이 암묵적으로 undefined를 넣고 초기화 해준다

var만 해당되는 얘기

```javascript
x = 1; 			// window.x = 1;
				// x 앞에 윈도우가 숨어있다
				// 전역객체의 프로퍼티
				// 부작용이 발생할 수 있다
console.log(x); // 1
```

선언문을 먼저 실행하니까 호이스팅 식별자 세트다

에러발생하면 안돼요 하지말고 에러읽어라

변수선언이 런타임 이전에 실행 그래서 호이스팅 발생



할당 저장 대입 등등 다 같은 얘기 영어로는 assignment

한줄이지만 두줄인것을 알아야한다

undefined + 1 = NaN

기존 변수에 있는데 다시 넣는것 재할당

왠만해선 안하는 것 해야될 필요가 있을수도 있어 가급적 피해라

왜 Why? 자바스크립트 특징 타입이 없다

```javascript
var n = 1;  // number
n = "1";	// string
n = true;	// boolean
			// type에 상관 없이 재할당이 가능하다
```



자바스크립트인데 타입이 있는 타입스크립트

오죽 문제가 많았으면 타입을 도입한 새로운 타입스크립트

const constunce 상수 줄임말 재할당 금지 처음 값을 방법이 없다 객체는 가능



변수 선언 하여 메모리공간 확보하여 undefined로 초기화

80을 가르키고 있는 메모리 공간을 가르킨다

덮어쓰지 않는 이유

데이터적 지식 변수가 가지고 있는게 아니라 값이 데이터 타입이 가지고 있다

데이터 타입은 두가지 방식

원시값(프리미티브, 기본 자료형 등) / 객체(object, 참조 등)

크게 두가지로 나누는 이유가 있겠죠 성격이 매우 다름

원시값 

- 변경 불가능(immutable)

  ```javascript
  var sum = 80;	// 80이 90으로 바뀌어서 변경이 된 것처럼 보이지만
  sum = 90;		// 메모리 값이 변경된 것이 아니라 메모리 주소를 바꾼 것이다
  				// 80이 있는 메모리 주소를 그대로 두고
  				// 90을 가지는 메모리 공간을 다시 파서 주소 변경해야됨
  				// 사용된 undefined, 80은 가비지컬렉터로 릴리스 된다
  				// 가비지 컬렉터가 언제 작동하는지는 알 수 없다
  ```

  |  식별자   | 메모리 주소 |  메모리   |
  | :-------: | :---------: | :-------: |
  |           | 0x0???????  |           |
  | ~~sum~~ ② | 0x0???????  |    80     |
  | ~~sum~~ ① | 0x0???????  | undefined |
  |           | 0x0???????  |           |
  |   sum ③   | 0x0???????  |    90     |

  

변경 undefined => 80 이 들어가야 공간

메모리 주소가 바뀌지 않는데에서 값이 바꼇다가 변경 불가능

undefined가 한번 자리 잡으면 그 메모리 공간은 no-touch

메모리 주소를 바꾸지 않는 이상 undefined를 바꿀 수 없다

재할당을 해도 값이 바뀌지 않는다라는 것과 같다

재할당을 하면 메모리 주소가 바뀐다

재할당을 하면서 메모리 주소가 안바뀐거 가져오면 상품줌

재할당을 하지 않으면서 값을 바꿀수 있는 친구들이 있다(객체)

값을 교체한거다

반드시 재할당을 해서 바꿈

원시값은 변경할 수가 없다

메모리 공간을 새로 만들어서 포인팅을 바꾼다

시간은 똑같애 어짜피 재활용

시간은 포인팅 바꾸는데 시간이 조금 들지만

차이는 거의 미비하다

객체

- 변경 가능(mutable)

자신이 바뀌었는지 안바뀌었는지 불분명함

값의 변경을 추적하기 어려움

리엑트에 가면 상태관리를 배움

그것을 왜 해야하는지가 변경 가능 / 불가능 때문에 그렇다

``` javascript
var x = 1;
var y = 2;
var z = y;	// z가 y의 메모리 주소를 갖는것이 아니라
		 	// z가 선언된 메모리 주소에 y의 값을 가져오는 것이다
		 	// 객체는 선언된 값을 참조하면 메모리 주소를 공유하기 때문에 한개가 바뀌면 같이 바뀐다
		 	// immuteableJS 프레임워크를 쓰거나 React를 쓰면 immutable하게 객체를 관리할 수 있다
y = x;		// y가 재사용이 불가해진다
x = z;

```

